
/* insertAfter's realization
*
* Вставка после текущего элемента  ( I )
*
* 1) 2 ноды связаны между собой.
*	Node_1.next = Node_2; (1)
*
*        Node_1					                             Node_2
*  --------------------                       --------------------
* | prev | data | Node_2 |	------------->	 | prev | data | next | 
*  --------------------			                  --------------------
*
* 2) Вставка новой ноды после Node_1
*
* Node_3.next = Node_1.next; // Node_1.next == Node_2    (2)
* Node_1.next = Node_3; // Сделать Node_3 следующей нодой     (3)
*
*        Node_1					   Node_2
*  --------------------                     --------------------
* | prev | data | Node_3 |	           | prev | data | next |
*  --------------------		            --------------------
*                   |                                     / \
*                   |                Node_3               |
*                   |       ----------------------        |
*                    ----> | prev | data | Node_2 | ------
*                           ----------------------
*
* ( II )
* В случае, если текущая нода - единственная в списке, просто добавить следующую,
* изменив указатель next;
*
*/

/*
*
* deleteAfter's realization
*
* 1) Связаны последовательно 3 ноды
* 
*        Node_1				           Node_2
*  --------------------                      --------------------
* | prev | data | Node_3 |	            | prev | data | next |
*  --------------------		             --------------------
*                   |                                    / \
*                   |                Node_3               |
*                   |       ----------------------        |
*                    ----> | prev | data | Node_2 | ------
*                           ----------------------
*
* Чтобы удалит элемент, идущий после текущего, нужно:
*  1) Завести промежуточную переменную, в которую записать адрес удаляемого узла
*  2) Текущему next присвоить next удаляемого узла, что будет означать
*		новую связь между элементами
*
*  Node<T>* temp = Node_1.next; // Node_1.next == Node_3 - запись удаляемого узла Node_3
*  Node_1.next = temp.next;     // temp.next == Node_2 - связь Node_1 и Node_2
*  return temp;     // Можно вернуть результат (например, чтобы в будущем освободить
*				    // указатель на удаленный элемент). Можно обойтись без этого
*
*         Node_1				     Node_2
*  --------------------                       --------------------
* | prev | data | Node_2 | ----------------> | prev | data | next |
*  --------------------			      --------------------
*                   |                                    / \
*                   -                                     |
*                   -                Node_3               |
*		    |       ----------------------        |
*                    ----> | prev | data | next |  --| |--
*                           ----------------------
*
*  Также обязательна проверка на пустоту Node_1.next для того, чтобы определить,
*  есть ли вообще элемент для удаления
*
*/

/*
*
*  Аналогичным образом должна быть построена работа с insertBefore и deleteBefore,
*  только задействован должен быть указатель prev.
*
*/
